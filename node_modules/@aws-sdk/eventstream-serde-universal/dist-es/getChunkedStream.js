import { __asyncGenerator, __await, __generator } from "tslib";
export function getChunkedStream(source) {
    var _a;
    var currentMessageTotalLength = 0;
    var currentMessagePendingLength = 0;
    var currentMessage = null;
    var messageLengthBuffer = null;
    var allocateMessage = function (size) {
        if (typeof size !== "number") {
            throw new Error("Attempted to allocate an event message where size was not a number: " + size);
        }
        currentMessageTotalLength = size;
        currentMessagePendingLength = 4;
        currentMessage = new Uint8Array(size);
        var currentMessageView = new DataView(currentMessage.buffer);
        currentMessageView.setUint32(0, size, false);
    };
    var iterator = function () {
        return __asyncGenerator(this, arguments, function () {
            var sourceIterator, _a, value, done, chunkLength, currentOffset, bytesRemaining, numBytesForTotal, numBytesToWrite;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        sourceIterator = source[Symbol.asyncIterator]();
                        _b.label = 1;
                    case 1:
                        if (!true) return [3, 16];
                        return [4, __await(sourceIterator.next())];
                    case 2:
                        _a = _b.sent(), value = _a.value, done = _a.done;
                        if (!done) return [3, 10];
                        if (!!currentMessageTotalLength) return [3, 4];
                        return [4, __await(void 0)];
                    case 3: return [2, _b.sent()];
                    case 4:
                        if (!(currentMessageTotalLength === currentMessagePendingLength)) return [3, 7];
                        return [4, __await(currentMessage)];
                    case 5: return [4, _b.sent()];
                    case 6:
                        _b.sent();
                        return [3, 8];
                    case 7: throw new Error("Truncated event message received.");
                    case 8: return [4, __await(void 0)];
                    case 9: return [2, _b.sent()];
                    case 10:
                        chunkLength = value.length;
                        currentOffset = 0;
                        _b.label = 11;
                    case 11:
                        if (!(currentOffset < chunkLength)) return [3, 15];
                        if (!currentMessage) {
                            bytesRemaining = chunkLength - currentOffset;
                            if (!messageLengthBuffer) {
                                messageLengthBuffer = new Uint8Array(4);
                            }
                            numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
                            messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
                            currentMessagePendingLength += numBytesForTotal;
                            currentOffset += numBytesForTotal;
                            if (currentMessagePendingLength < 4) {
                                return [3, 15];
                            }
                            allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
                            messageLengthBuffer = null;
                        }
                        numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
                        currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
                        currentMessagePendingLength += numBytesToWrite;
                        currentOffset += numBytesToWrite;
                        if (!(currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength)) return [3, 14];
                        return [4, __await(currentMessage)];
                    case 12: return [4, _b.sent()];
                    case 13:
                        _b.sent();
                        currentMessage = null;
                        currentMessageTotalLength = 0;
                        currentMessagePendingLength = 0;
                        _b.label = 14;
                    case 14: return [3, 11];
                    case 15: return [3, 1];
                    case 16: return [2];
                }
            });
        });
    };
    return _a = {},
        _a[Symbol.asyncIterator] = iterator,
        _a;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0Q2h1bmtlZFN0cmVhbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9nZXRDaHVua2VkU3RyZWFtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsTUFBaUM7O0lBQ2hFLElBQUkseUJBQXlCLEdBQUcsQ0FBQyxDQUFDO0lBQ2xDLElBQUksMkJBQTJCLEdBQUcsQ0FBQyxDQUFDO0lBQ3BDLElBQUksY0FBYyxHQUFzQixJQUFJLENBQUM7SUFDN0MsSUFBSSxtQkFBbUIsR0FBc0IsSUFBSSxDQUFDO0lBQ2xELElBQU0sZUFBZSxHQUFHLFVBQUMsSUFBWTtRQUNuQyxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxHQUFHLElBQUksQ0FBQyxDQUFDO1NBQ2hHO1FBQ0QseUJBQXlCLEdBQUcsSUFBSSxDQUFDO1FBQ2pDLDJCQUEyQixHQUFHLENBQUMsQ0FBQztRQUNoQyxjQUFjLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEMsSUFBTSxrQkFBa0IsR0FBRyxJQUFJLFFBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDL0Qsa0JBQWtCLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDL0MsQ0FBQyxDQUFDO0lBRUYsSUFBTSxRQUFRLEdBQUc7Ozs7Ozt3QkFDVCxjQUFjLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDOzs7NkJBQy9DLElBQUk7d0JBQ2UsbUJBQU0sY0FBYyxDQUFDLElBQUksRUFBRSxHQUFBOzt3QkFBN0MsS0FBa0IsU0FBMkIsRUFBM0MsS0FBSyxXQUFBLEVBQUUsSUFBSSxVQUFBOzZCQUNmLElBQUksRUFBSixlQUFJOzZCQUNGLENBQUMseUJBQXlCLEVBQTFCLGNBQTBCOzs0QkFDNUIsc0JBQU87OzZCQUNFLENBQUEseUJBQXlCLEtBQUssMkJBQTJCLENBQUEsRUFBekQsY0FBeUQ7MkNBQzVELGNBQTRCOzRCQUFsQyxzQkFBa0M7O3dCQUFsQyxTQUFrQyxDQUFDOzs0QkFFbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDOzs0QkFFdkQsc0JBQU87O3dCQUdILFdBQVcsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO3dCQUM3QixhQUFhLEdBQUcsQ0FBQyxDQUFDOzs7NkJBRWYsQ0FBQSxhQUFhLEdBQUcsV0FBVyxDQUFBO3dCQUVoQyxJQUFJLENBQUMsY0FBYyxFQUFFOzRCQUViLGNBQWMsR0FBRyxXQUFXLEdBQUcsYUFBYSxDQUFDOzRCQUVuRCxJQUFJLENBQUMsbUJBQW1CLEVBQUU7Z0NBQ3hCLG1CQUFtQixHQUFHLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDOzZCQUN6Qzs0QkFDSyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUMvQixDQUFDLEdBQUcsMkJBQTJCLEVBQy9CLGNBQWMsQ0FDZixDQUFDOzRCQUVGLG1CQUFtQixDQUFDLEdBQUcsQ0FFckIsS0FBSyxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsYUFBYSxHQUFHLGdCQUFnQixDQUFDLEVBQzVELDJCQUEyQixDQUM1QixDQUFDOzRCQUVGLDJCQUEyQixJQUFJLGdCQUFnQixDQUFDOzRCQUNoRCxhQUFhLElBQUksZ0JBQWdCLENBQUM7NEJBRWxDLElBQUksMkJBQTJCLEdBQUcsQ0FBQyxFQUFFO2dDQUVuQyxlQUFNOzZCQUNQOzRCQUNELGVBQWUsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7NEJBQzlFLG1CQUFtQixHQUFHLElBQUksQ0FBQzt5QkFDNUI7d0JBR0ssZUFBZSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQzlCLHlCQUF5QixHQUFHLDJCQUEyQixFQUN2RCxXQUFXLEdBQUcsYUFBYSxDQUM1QixDQUFDO3dCQUNGLGNBQWUsQ0FBQyxHQUFHLENBRWpCLEtBQUssQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLGFBQWEsR0FBRyxlQUFlLENBQUMsRUFDM0QsMkJBQTJCLENBQzVCLENBQUM7d0JBQ0YsMkJBQTJCLElBQUksZUFBZSxDQUFDO3dCQUMvQyxhQUFhLElBQUksZUFBZSxDQUFDOzZCQUc3QixDQUFBLHlCQUF5QixJQUFJLHlCQUF5QixLQUFLLDJCQUEyQixDQUFBLEVBQXRGLGVBQXNGOzJDQUVsRixjQUE0Qjs2QkFBbEMsc0JBQWtDOzt3QkFBbEMsU0FBa0MsQ0FBQzt3QkFFbkMsY0FBYyxHQUFHLElBQUksQ0FBQzt3QkFDdEIseUJBQXlCLEdBQUcsQ0FBQyxDQUFDO3dCQUM5QiwyQkFBMkIsR0FBRyxDQUFDLENBQUM7Ozs7Ozs7O0tBSXZDLENBQUM7SUFFRjtRQUNFLEdBQUMsTUFBTSxDQUFDLGFBQWEsSUFBRyxRQUFRO1dBQ2hDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBnZXRDaHVua2VkU3RyZWFtKHNvdXJjZTogQXN5bmNJdGVyYWJsZTxVaW50OEFycmF5Pik6IEFzeW5jSXRlcmFibGU8VWludDhBcnJheT4ge1xuICBsZXQgY3VycmVudE1lc3NhZ2VUb3RhbExlbmd0aCA9IDA7XG4gIGxldCBjdXJyZW50TWVzc2FnZVBlbmRpbmdMZW5ndGggPSAwO1xuICBsZXQgY3VycmVudE1lc3NhZ2U6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbDtcbiAgbGV0IG1lc3NhZ2VMZW5ndGhCdWZmZXI6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbDtcbiAgY29uc3QgYWxsb2NhdGVNZXNzYWdlID0gKHNpemU6IG51bWJlcikgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGFsbG9jYXRlIGFuIGV2ZW50IG1lc3NhZ2Ugd2hlcmUgc2l6ZSB3YXMgbm90IGEgbnVtYmVyOiBcIiArIHNpemUpO1xuICAgIH1cbiAgICBjdXJyZW50TWVzc2FnZVRvdGFsTGVuZ3RoID0gc2l6ZTtcbiAgICBjdXJyZW50TWVzc2FnZVBlbmRpbmdMZW5ndGggPSA0O1xuICAgIGN1cnJlbnRNZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgY29uc3QgY3VycmVudE1lc3NhZ2VWaWV3ID0gbmV3IERhdGFWaWV3KGN1cnJlbnRNZXNzYWdlLmJ1ZmZlcik7XG4gICAgY3VycmVudE1lc3NhZ2VWaWV3LnNldFVpbnQzMigwLCBzaXplLCBmYWxzZSk7IC8vc2V0IGJpZy1lbmRpYW4gVWludDMyIHRvIDB+MyBieXRlc1xuICB9O1xuXG4gIGNvbnN0IGl0ZXJhdG9yID0gYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBzb3VyY2VJdGVyYXRvciA9IHNvdXJjZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgc291cmNlSXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50TWVzc2FnZVRvdGFsTGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRNZXNzYWdlVG90YWxMZW5ndGggPT09IGN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCkge1xuICAgICAgICAgIHlpZWxkIGN1cnJlbnRNZXNzYWdlIGFzIFVpbnQ4QXJyYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJ1bmNhdGVkIGV2ZW50IG1lc3NhZ2UgcmVjZWl2ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2h1bmtMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICBsZXQgY3VycmVudE9mZnNldCA9IDA7XG5cbiAgICAgIHdoaWxlIChjdXJyZW50T2Zmc2V0IDwgY2h1bmtMZW5ndGgpIHtcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBtZXNzYWdlIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoIWN1cnJlbnRNZXNzYWdlKSB7XG4gICAgICAgICAgLy8gd29ya2luZyBvbiBhIG5ldyBtZXNzYWdlLCBkZXRlcm1pbmUgdG90YWwgbGVuZ3RoXG4gICAgICAgICAgY29uc3QgYnl0ZXNSZW1haW5pbmcgPSBjaHVua0xlbmd0aCAtIGN1cnJlbnRPZmZzZXQ7XG4gICAgICAgICAgLy8gcHJldmVudCBlZGdlIGNhc2Ugd2hlcmUgdG90YWwgbGVuZ3RoIHNwYW5zIDIgY2h1bmtzXG4gICAgICAgICAgaWYgKCFtZXNzYWdlTGVuZ3RoQnVmZmVyKSB7XG4gICAgICAgICAgICBtZXNzYWdlTGVuZ3RoQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG51bUJ5dGVzRm9yVG90YWwgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIDQgLSBjdXJyZW50TWVzc2FnZVBlbmRpbmdMZW5ndGgsIC8vIHJlbWFpbmluZyBieXRlcyB0byBmaWxsIHRoZSBtZXNzYWdlTGVuZ3RoQnVmZmVyXG4gICAgICAgICAgICBieXRlc1JlbWFpbmluZyAvLyBieXRlcyBsZWZ0IGluIGNodW5rXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIG1lc3NhZ2VMZW5ndGhCdWZmZXIuc2V0KFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBlcnJvciBUUzI1MzI6IE9iamVjdCBpcyBwb3NzaWJseSAndW5kZWZpbmVkJyBmb3IgdmFsdWVcbiAgICAgICAgICAgIHZhbHVlLnNsaWNlKGN1cnJlbnRPZmZzZXQsIGN1cnJlbnRPZmZzZXQgKyBudW1CeXRlc0ZvclRvdGFsKSxcbiAgICAgICAgICAgIGN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjdXJyZW50TWVzc2FnZVBlbmRpbmdMZW5ndGggKz0gbnVtQnl0ZXNGb3JUb3RhbDtcbiAgICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IG51bUJ5dGVzRm9yVG90YWw7XG5cbiAgICAgICAgICBpZiAoY3VycmVudE1lc3NhZ2VQZW5kaW5nTGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhlIGN1cnJlbnQgbWVzc2FnZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFsbG9jYXRlTWVzc2FnZShuZXcgRGF0YVZpZXcobWVzc2FnZUxlbmd0aEJ1ZmZlci5idWZmZXIpLmdldFVpbnQzMigwLCBmYWxzZSkpO1xuICAgICAgICAgIG1lc3NhZ2VMZW5ndGhCdWZmZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd3JpdGUgZGF0YSBpbnRvIGN1cnJlbnQgbWVzc2FnZVxuICAgICAgICBjb25zdCBudW1CeXRlc1RvV3JpdGUgPSBNYXRoLm1pbihcbiAgICAgICAgICBjdXJyZW50TWVzc2FnZVRvdGFsTGVuZ3RoIC0gY3VycmVudE1lc3NhZ2VQZW5kaW5nTGVuZ3RoLCAvLyBudW1iZXIgb2YgYnl0ZXMgbGVmdCB0byBjb21wbGV0ZSBtZXNzYWdlXG4gICAgICAgICAgY2h1bmtMZW5ndGggLSBjdXJyZW50T2Zmc2V0IC8vIG51bWJlciBvZiBieXRlcyBsZWZ0IGluIHRoZSBvcmlnaW5hbCBjaHVua1xuICAgICAgICApO1xuICAgICAgICBjdXJyZW50TWVzc2FnZSEuc2V0KFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgZXJyb3IgVFMyNTMyOiBPYmplY3QgaXMgcG9zc2libHkgJ3VuZGVmaW5lZCcgZm9yIHZhbHVlXG4gICAgICAgICAgdmFsdWUuc2xpY2UoY3VycmVudE9mZnNldCwgY3VycmVudE9mZnNldCArIG51bUJ5dGVzVG9Xcml0ZSksXG4gICAgICAgICAgY3VycmVudE1lc3NhZ2VQZW5kaW5nTGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnRNZXNzYWdlUGVuZGluZ0xlbmd0aCArPSBudW1CeXRlc1RvV3JpdGU7XG4gICAgICAgIGN1cnJlbnRPZmZzZXQgKz0gbnVtQnl0ZXNUb1dyaXRlO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGEgbWVzc2FnZSBpcyByZWFkeSB0byBiZSBwdXNoZWRcbiAgICAgICAgaWYgKGN1cnJlbnRNZXNzYWdlVG90YWxMZW5ndGggJiYgY3VycmVudE1lc3NhZ2VUb3RhbExlbmd0aCA9PT0gY3VycmVudE1lc3NhZ2VQZW5kaW5nTGVuZ3RoKSB7XG4gICAgICAgICAgLy8gcHVzaCBvdXQgdGhlIG1lc3NhZ2VcbiAgICAgICAgICB5aWVsZCBjdXJyZW50TWVzc2FnZSBhcyBVaW50OEFycmF5O1xuICAgICAgICAgIC8vIGNsZWFudXBcbiAgICAgICAgICBjdXJyZW50TWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgY3VycmVudE1lc3NhZ2VUb3RhbExlbmd0aCA9IDA7XG4gICAgICAgICAgY3VycmVudE1lc3NhZ2VQZW5kaW5nTGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl06IGl0ZXJhdG9yLFxuICB9O1xufVxuIl19