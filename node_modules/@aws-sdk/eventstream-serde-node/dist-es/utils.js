import { __asyncGenerator, __await, __generator } from "tslib";
export function readabletoIterable(readStream) {
    return __asyncGenerator(this, arguments, function readabletoIterable_1() {
        var streamEnded, generationEnded, records, value;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    streamEnded = false;
                    generationEnded = false;
                    records = new Array();
                    readStream.on("error", function (err) {
                        if (!streamEnded) {
                            streamEnded = true;
                        }
                        if (err) {
                            throw err;
                        }
                    });
                    readStream.on("data", function (data) {
                        records.push(data);
                    });
                    readStream.on("end", function () {
                        streamEnded = true;
                    });
                    _a.label = 1;
                case 1:
                    if (!!generationEnded) return [3, 6];
                    return [4, __await(new Promise(function (resolve) { return setTimeout(function () { return resolve(records.shift()); }, 0); }))];
                case 2:
                    value = _a.sent();
                    if (!value) return [3, 5];
                    return [4, __await(value)];
                case 3: return [4, _a.sent()];
                case 4:
                    _a.sent();
                    _a.label = 5;
                case 5:
                    generationEnded = streamEnded && records.length === 0;
                    return [3, 1];
                case 6: return [2];
            }
        });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQVVBLE1BQU0sVUFBaUIsa0JBQWtCLENBQUksVUFBb0I7Ozs7OztvQkFDM0QsV0FBVyxHQUFHLEtBQUssQ0FBQztvQkFDcEIsZUFBZSxHQUFHLEtBQUssQ0FBQztvQkFDdEIsT0FBTyxHQUFHLElBQUksS0FBSyxFQUFLLENBQUM7b0JBRS9CLFVBQVUsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLFVBQUMsR0FBRzt3QkFDekIsSUFBSSxDQUFDLFdBQVcsRUFBRTs0QkFDaEIsV0FBVyxHQUFHLElBQUksQ0FBQzt5QkFDcEI7d0JBQ0QsSUFBSSxHQUFHLEVBQUU7NEJBQ1AsTUFBTSxHQUFHLENBQUM7eUJBQ1g7b0JBQ0gsQ0FBQyxDQUFDLENBQUM7b0JBRUgsVUFBVSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsVUFBQyxJQUFJO3dCQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUNyQixDQUFDLENBQUMsQ0FBQztvQkFFSCxVQUFVLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRTt3QkFDbkIsV0FBVyxHQUFHLElBQUksQ0FBQztvQkFDckIsQ0FBQyxDQUFDLENBQUM7Ozt5QkFFSSxDQUFDLGVBQWU7b0JBRVAsbUJBQU0sSUFBSSxPQUFPLENBQUksVUFBQyxPQUFPLElBQUssT0FBQSxVQUFVLENBQUMsY0FBTSxPQUFBLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBeEIsQ0FBd0IsRUFBRSxDQUFDLENBQUMsRUFBN0MsQ0FBNkMsQ0FBQyxHQUFBOztvQkFBeEYsS0FBSyxHQUFHLFNBQWdGO3lCQUMxRixLQUFLLEVBQUwsY0FBSzt1Q0FDRCxLQUFLO3dCQUFYLHNCQUFXOztvQkFBWCxTQUFXLENBQUM7OztvQkFFZCxlQUFlLEdBQUcsV0FBVyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDOzs7Ozs7Q0FFekQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gXCJzdHJlYW1cIjtcblxuLyoqXG4gKiBDb252ZXJ0IG9iamVjdCBzdHJlYW0gcGlwZWQgaW4gaW50byBhbiBhc3luYyBpdGVyYWJsZS4gVGhpc1xuICogZGFwdG9yIHNob3VsZCBiZSBkZXByZWNhdGVkIHdoZW4gTm9kZSBzdHJlYW0gaXRlcmF0b3IgaXMgc3RhYmxlLlxuICogQ2F2ZWF0OiB0aGlzIGFkYXB0b3Igd29uJ3QgaGF2ZSBiYWNrcHJlc3N1cmUgdG8gaW53YXJkcyBzdHJlYW1cbiAqXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vbm9kZWpzLm9yZy9kb2NzL2xhdGVzdC12MTEueC9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3JlYWRhYmxlX3N5bWJvbF9hc3luY2l0ZXJhdG9yXG4gKi9cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiByZWFkYWJsZXRvSXRlcmFibGU8VD4ocmVhZFN0cmVhbTogUmVhZGFibGUpOiBBc3luY0l0ZXJhYmxlPFQ+IHtcbiAgbGV0IHN0cmVhbUVuZGVkID0gZmFsc2U7XG4gIGxldCBnZW5lcmF0aW9uRW5kZWQgPSBmYWxzZTtcbiAgY29uc3QgcmVjb3JkcyA9IG5ldyBBcnJheTxUPigpO1xuXG4gIHJlYWRTdHJlYW0ub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgaWYgKCFzdHJlYW1FbmRlZCkge1xuICAgICAgc3RyZWFtRW5kZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9KTtcblxuICByZWFkU3RyZWFtLm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgIHJlY29yZHMucHVzaChkYXRhKTtcbiAgfSk7XG5cbiAgcmVhZFN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgc3RyZWFtRW5kZWQgPSB0cnVlO1xuICB9KTtcblxuICB3aGlsZSAoIWdlbmVyYXRpb25FbmRlZCkge1xuICAgIC8vIEB0cy1pZ25vcmUgVFMyMzQ1OiBBcmd1bWVudCBvZiB0eXBlICdUIHwgdW5kZWZpbmVkJyBpcyBub3QgYXNzaWduYWJsZSB0byB0eXBlICdUIHwgUHJvbWlzZUxpa2U8VD4nLlxuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgbmV3IFByb21pc2U8VD4oKHJlc29sdmUpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShyZWNvcmRzLnNoaWZ0KCkpLCAwKSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gICAgZ2VuZXJhdGlvbkVuZGVkID0gc3RyZWFtRW5kZWQgJiYgcmVjb3Jkcy5sZW5ndGggPT09IDA7XG4gIH1cbn1cbiJdfQ==